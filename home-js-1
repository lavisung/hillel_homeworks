'number' + 3 + 3; "number33"
/* Оскільки один з елементів є рядком, то інші елементи неявно перетворюються
в рядки і відбувається конкатенація*/

null + 3; 3
/* Null неявно перетворюється у 0, а потім складаються два числа */

5 && "qwerty"; "qwerty"
/* число 5 є true і непустий рядок теж true, відповідно логічний вираз з
'&&' є true, а оскільки він true, то вираз віддає останній true елемент'*/

+'40' + +'2' + "hillel"; "42hillel"
/* унарний оператор перетворює рядок в число, тому 40 і 2 складаються
як числа, а потім конкатенуються до рядка і результат рядок */

'10' - 5 === 6;false
/* '10' неявно приводиться до числа, виконується операція
віднімання "10-5=5" і потім 5 строго порівнюється з 6 і вираз віддає false  */

true + false; 1
/* true і false неявно перетворюються в 0 і 1 через операцію
складання, вони сумуються і вираз
віддає 1 */

'4px' - 3; NaN
/* "4px" не може бути приведене до числа, тому при спробі віднімання числа
від рядка отримуємо NaN */

'4' - 3; 1
/* '4' приводиться до числа, оскільки операція віднімання, і результат
віднімання виходить число 1  */

'6' + 3 ** 0; "61"
/* 3 піднести до 0 буде 1, а оскільки стоїть "+", то зі стрінгою "6" відбу-
ваєьться операція конкатенації*/

12 / '6'; 2
/* через оператор ділення "6" неявно приводиться до числа і відбувається
звичайна операція ділення */

'10' + (5 === 6); "10false"
/* спочатку виконується вираз у дужках. результатом його виконання є
false, а потім булевий оператор приводиться до рядка і відбувається
конкатенація*/

null == ''; false
/* null не дорівнює нічому, окрім undefined, тому вираз повертає false */

3 ** (9 / 3); 27
/* спочатку виконається вираз у дужках. результатом його виконанна є число 3,
а потім 3 підноситься до 3 степені */

!!'false' == !!'true'; true
/* два знака оклику приводять ці рядки в булеве значення, а оскільки вони
не пусті, то приводяться вони до true і результатом буде true*/

0 || '0' && 1; true
/* операція логічного"І" відбувається раніше за "АБО".
непустий рядок і число дають true. потім 0 в лівій
частині приводиться до false і
у виразі false АБО true повертається true */

(+null == false) < 1; false
/* null з унарним оператором приводиться до 0, false також приводиться
до 0. "0 == 0" буде true, а true це 1. далі відбувається порівняння
"1<1" і повертається false */

false && true || true; true
/* "false && true" дає false, а потім "false || true" дає true */

false && (false || true); false
/* спочатку виконується операція в дужках. "false || true" дає true. потім
виконується вираз "false && true" і він віддає false */

(+null == false) < 1 ** 5; false
/* null з унарним оператором приводиться до 0, false також приводиться
до 0. "0 == 0" буде true, а true це 1. далі
в іншій частині виразу 1 підноситься до 5, це буде 1. і далі
відбувається порівняння "1<1", що є false */
